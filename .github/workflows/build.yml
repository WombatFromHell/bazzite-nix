---
name: Build Custom Image
on:
  schedule:
    - cron: "0 3 * * *" # 03:00 UTC every day
  workflow_dispatch:
    inputs:
      force_build:
        description: "Force build even if digest unchanged"
        required: false
        default: false
        type: boolean
      skip_rechunk:
        description: "Skip rechunk step (faster build, larger layers)"
        required: false
        default: false
        type: boolean

env:
  IMAGE_NAME: "${{ github.event.repository.name }}"
  IMAGE_DESC: "Bazzite Testing image with Nix mount support"
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build_push:
    name: Build and push image
    runs-on: ubuntu-24.04
    strategy:
      fail-fast: false
      matrix:
        include:
          - variant: "stable"
            base_image: "ghcr.io/ublue-os/bazzite:stable"
          - variant: "testing"
            base_image: "ghcr.io/ublue-os/bazzite:testing"
          # - variant: "deck"
          #   base_image: "ghcr.io/ublue-os/bazzite-deck:stable"

    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Mount BTRFS for podman storage
        uses: ublue-os/container-storage-action@main
        with:
          target-dir: /var/lib/containers

      - name: Set timestamps
        id: date
        run: |
          echo "date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Lowercase Registry and Image
        id: lowercase
        run: |
          REGISTRY_LOWER=$(echo "${{ env.IMAGE_REGISTRY }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
          echo "registry_lower=${REGISTRY_LOWER}" >> $GITHUB_OUTPUT
          echo "image_lower=${IMAGE_LOWER}" >> $GITHUB_OUTPUT

      - name: Generate cache keys
        id: cache_keys
        shell: bash
        run: |
          VARIANT_HASH=$(echo "${{ matrix.variant }}" | sha256sum | cut -c1-8)
          REPO_HASH=$(echo "${{ github.repository }}" | sha256sum | cut -c1-8)
          BRANCH_HASH=$(echo "${{ github.ref_name }}" | sha256sum | cut -c1-8)
          BASE_KEY="digest-${REPO_HASH}-${BRANCH_HASH}-${VARIANT_HASH}"
          RESTORE_KEY="${BASE_KEY}-"
          echo "restore_key=${RESTORE_KEY}" >> $GITHUB_OUTPUT
          echo "base_key=${BASE_KEY}" >> $GITHUB_OUTPUT

      - name: Restore digest cache
        id: restore_cache
        uses: actions/cache/restore@v4
        with:
          path: .digest-cache
          restore-keys: |
            ${{ steps.cache_keys.outputs.restore_key }}
          key: ${{ steps.cache_keys.outputs.base_key }}-never-matches

      - name: Login for Skopeo
        run: echo "${{ secrets.GITHUB_TOKEN }}" | skopeo login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Extract metadata from upstream image
        id: metadata
        run: |
          BASE_IMAGE="${{ matrix.base_image }}"
          echo "Inspecting upstream base image: $BASE_IMAGE"
          # Retry up to 3 times on failure
          for i in {1..3}; do
            if INSPECT_OUTPUT=$(skopeo inspect "docker://$BASE_IMAGE" 2>/dev/null); then
              # Extract version label (required)
              PARENT_VERSION=$(echo "$INSPECT_OUTPUT" | jq -r '.Labels["org.opencontainers.image.version"] // empty')
              # Extract full digest
              DIGEST=$(echo "$INSPECT_OUTPUT" | jq -r '.Digest // empty' | sed 's/sha256://')
              # Validate version
              if [ -z "$PARENT_VERSION" ] || [ "$PARENT_VERSION" = "null" ] || [ "$PARENT_VERSION" = "latest" ]; then
                echo "::error::Upstream image missing or invalid 'org.opencontainers.image.version' label"
                exit 1
              fi
              # Validate digest
              if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ]; then
                echo "::error::Failed to extract valid digest from upstream image"
                exit 1
              fi

              echo "parent_version=$PARENT_VERSION" >> $GITHUB_OUTPUT
              echo "digest=$DIGEST" >> $GITHUB_OUTPUT
              echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
              echo "Successfully extracted metadata: version=$PARENT_VERSION, digest=$DIGEST"
              exit 0
            else
              echo "Attempt $i: Failed to inspect $BASE_IMAGE"
              if [ $i -lt 3 ]; then
                sleep 10
              else
                echo "::error::Failed to inspect upstream image after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: Compute image tags
        id: compute_tags
        run: |
          PARENT_VERSION="${{ steps.metadata.outputs.parent_version }}"
          case "${{ matrix.variant }}" in
            "stable")
              TAGS="stable,stable-${PARENT_VERSION},${PARENT_VERSION}"
              CANONICAL="stable-${PARENT_VERSION}"
              ;;
            "testing")
              # assume 'testing' is always the most cutting-edge by tagging it 'latest'
              TAGS="testing,latest,${PARENT_VERSION}"
              CANONICAL="${PARENT_VERSION}"
              ;;
            "deck")
              TAGS="deck,deck-${PARENT_VERSION}"
              CANONICAL="deck-${PARENT_VERSION}"
              ;;
            *) echo "Unknown variant"; exit 1 ;;
          esac
          echo "tags=$TAGS" >> $GITHUB_OUTPUT
          echo "canonical_tag=$CANONICAL" >> $GITHUB_OUTPUT

      - name: Check if canonical tag already exists
        if: github.event.inputs.force_build != 'true'
        id: check_exists
        run: |
          PREFIX="${{ steps.lowercase.outputs.registry_lower }}/${{ steps.lowercase.outputs.image_lower }}"
          CANONICAL_TAG="${{ steps.compute_tags.outputs.canonical_tag }}"
          IMAGE_REF="${PREFIX}:${CANONICAL_TAG}"
          echo "Checking existence of canonical tag: $IMAGE_REF"
          if skopeo inspect "docker://${IMAGE_REF}" > /dev/null 2>&1; then
            echo "::warning::Build skipped — canonical image already exists"
            echo "## ⚠️ Build Skipped" >> $GITHUB_STEP_SUMMARY
            echo "**Reason:** Canonical image already exists at ${IMAGE_REF}" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Generate final cache key and compare
        id: compare
        run: |
          BASE_KEY="${{ steps.cache_keys.outputs.base_key }}"
          CURRENT_DIGEST="${{ steps.metadata.outputs.digest }}"
          FINAL_KEY="${BASE_KEY}-${CURRENT_DIGEST}"
          if [ "${{ github.event.inputs.force_build }}" = "true" ]; then
            CHANGED=true
            REASON="Force build requested"
          elif [ "${{ steps.restore_cache.outputs.cache-hit }}" != "true" ]; then
            CHANGED=true
            REASON="No previous cache found"
          else
            if [ -f .digest-cache/last_digest ]; then
              CACHED_DIGEST=$(<.digest-cache/last_digest)
              if [ "$CURRENT_DIGEST" = "$CACHED_DIGEST" ]; then
                CHANGED=false
                REASON="Digest unchanged: $CURRENT_DIGEST"
              else
                CHANGED=true
                REASON="Digest changed from $CACHED_DIGEST to $CURRENT_DIGEST"
              fi
            else
              CHANGED=true
              REASON="Cache restored but no digest file"
            fi
          fi
          echo "changed=$CHANGED" >> $GITHUB_OUTPUT
          echo "reason=$REASON" >> $GITHUB_OUTPUT
          echo "final_cache_key=${FINAL_KEY}" >> $GITHUB_OUTPUT

      - name: Build decision
        id: decide
        run: |
          if [ "${{ steps.compare.outputs.changed }}" == "true" ]; then
            echo "Build proceeding: ${{ steps.compare.outputs.reason }}"
          else
            echo "::warning::Build skipped — no changes detected"
            echo "## ⚠️ Build Skipped" >> $GITHUB_STEP_SUMMARY
            echo "**Reason:** ${{ steps.compare.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
            echo "**Current digest:** \`${{ steps.metadata.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Assemble image labels
        id: labels
        run: |
          LABELS=$(cat <<EOF
          org.opencontainers.image.created=${{ steps.date.outputs.date }}
          org.opencontainers.image.description=${{ env.IMAGE_DESC }}
          org.opencontainers.image.documentation=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/refs/heads/main/README.md
          org.opencontainers.image.source=https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/blob/main/Containerfile
          org.opencontainers.image.title=${{ steps.lowercase.outputs.image_lower }}
          org.opencontainers.image.url=https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}
          org.opencontainers.image.vendor=${{ github.repository_owner }}
          org.opencontainers.image.version=${{ steps.metadata.outputs.parent_version }}
          containers.bootc=1
          EOF
          )
          echo "rechunk_labels<<EOF" >> $GITHUB_OUTPUT
          echo "$LABELS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          BUILDAH_ARGS=""
          while IFS= read -r line; do
            [ -n "$line" ] && BUILDAH_ARGS="$BUILDAH_ARGS --label \"$line\""
          done <<< "$LABELS"
          echo "buildah_args<<EOF" >> $GITHUB_OUTPUT
          echo "$BUILDAH_ARGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build image
        id: build_image
        run: |
          if [ "${{ github.event.inputs.skip_rechunk }}" != "true" ]; then
            sudo buildah build \
              --tag localhost/raw-img ${{ steps.labels.outputs.buildah_args }} \
              --build-arg BASE_IMAGE="${{ matrix.base_image }}" \
              --file ./Containerfile && \
                echo "skopeo_ref=containers-storage:localhost/raw-img" >> $GITHUB_OUTPUT
          else
            sudo buildah build \
              --tag raw-img --build-arg BASE_IMAGE="${{ matrix.base_image }}" \
              --file ./Containerfile && \
                echo "skopeo_ref=containers-storage:raw-img" >> $GITHUB_OUTPUT
          fi

      - name: Check if previous image exists
        id: check_prev
        run: |
          PREV_REF="${{ steps.lowercase.outputs.registry_lower }}/${{ steps.lowercase.outputs.image_lower }}:${{ matrix.variant }}"
          echo "Checking existence of previous image: $PREV_REF"
          if skopeo inspect "docker://${PREV_REF}" > /dev/null 2>&1; then
            echo "prev_ref_exists=true" >> $GITHUB_OUTPUT
          else
            echo "prev_ref_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Run Rechunker
        if: github.event.inputs.skip_rechunk != true && steps.check_prev.outputs.prev_ref_exists == 'true'
        uses: hhd-dev/rechunk@ded27feba22df48134eece2c66ba0fca1289ff40
        with:
          rechunk: "ghcr.io/hhd-dev/rechunk:v1.2.3"
          ref: "raw-img"
          prev-ref: "${{ steps.lowercase.outputs.registry_lower }}/${{ steps.lowercase.outputs.image_lower }}:${{ matrix.variant }}"
          max-layers: 40
          labels: ${{ steps.labels.outputs.rechunk_labels }}

      - name: Get build digest
        id: build_digest
        run: |
          SKIP_RECHUNK="${{ github.event.inputs.skip_rechunk }}"
          RECHUNK_REF="${{ steps.rechunk.outputs.ref }}"

          if [ "$SKIP_RECHUNK" == "true" ]; then
            IMAGE_REF="${{ steps.build_image.outputs.skopeo_ref }}"
          elif [ -n "$RECHUNK_REF" ]; then
            IMAGE_REF="$RECHUNK_REF"
          else
            # Rechunk was skipped (e.g., no previous image), use raw build
            IMAGE_REF="${{ steps.build_image.outputs.skopeo_ref }}"
          fi

          if [ -z "$IMAGE_REF" ]; then
            echo "::error::No valid image reference found to inspect"
            exit 1
          fi

          echo "Using image ref: $IMAGE_REF"
          FULL_BUILD_DIGEST=$(sudo skopeo inspect --format='{{.Digest}}' "$IMAGE_REF")
          BUILD_DIGEST=$(echo "$FULL_BUILD_DIGEST" | sed 's/sha256://')
          echo "full_build_digest=${FULL_BUILD_DIGEST}" >> $GITHUB_OUTPUT
          echo "build_digest=${BUILD_DIGEST}" >> $GITHUB_OUTPUT
          echo "source_ref=${IMAGE_REF}" >> $GITHUB_OUTPUT

      - name: Push To GHCR
        uses: Wandalen/wretry.action@e68c23e6309f2871ca8ae4763e7629b9c258e1ea
        with:
          attempt_limit: 3
          attempt_delay: 15000
          command: |
            SOURCE_REF="${{ steps.build_digest.outputs.source_ref }}"

            IFS=',' read -r -a tags <<< "${{ steps.compute_tags.outputs.tags }}"
            echo "Pushing tags: ${tags[*]}"

            BASE_IMG="docker://${{ steps.lowercase.outputs.registry_lower }}/${{ steps.lowercase.outputs.image_lower }}"
            PRIMARY_TAG="${tags[0]}"
            sudo skopeo copy ${SOURCE_REF} ${BASE_IMG}:${PRIMARY_TAG}

            for tag in "${tags[@]:1}"; do
              sudo skopeo copy ${BASE_IMG}:${PRIMARY_TAG} ${BASE_IMG}:${tag}
            done

      - name: Save digest to cache
        if: steps.compare.outputs.changed == 'true'
        run: |
          mkdir -p .digest-cache
          echo "${{ steps.metadata.outputs.digest }}" > .digest-cache/last_digest

      - name: Save new cache
        if: steps.compare.outputs.changed == 'true'
        uses: actions/cache/save@v4
        with:
          path: .digest-cache
          key: ${{ steps.compare.outputs.final_cache_key }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.10.0

      - name: Sign container image
        run: |
          IMAGE_DIGEST="${{ steps.build_digest.outputs.full_build_digest }}"
          IMAGE_REGISTRY="${{ steps.lowercase.outputs.registry_lower }}"
          IMAGE_NAME="${{ steps.lowercase.outputs.image_lower }}"
          echo "Signing image: ${IMAGE_REGISTRY}/${IMAGE_NAME}@${IMAGE_DIGEST}"
          echo "${{ secrets.GITHUB_TOKEN }}" | cosign login ghcr.io -u ${{ github.actor }} --password-stdin
          cosign sign -y --key env://COSIGN_PRIVATE_KEY ${IMAGE_REGISTRY}/${IMAGE_NAME}@${IMAGE_DIGEST}
        env:
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}
